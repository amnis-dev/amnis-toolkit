## API Report File for "@reduxjs/toolkit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Action } from 'redux';
import { ActionCreator } from 'redux';
import { autotrackMemoize } from 'reselect';
import { produce as createNextState } from 'immer';
import { createSelector } from 'reselect';
import { createSelectorCreator } from 'reselect';
import { CreateSelectorFunction } from 'reselect';
import { current } from 'immer';
import { defaultMemoize } from 'reselect';
import { DefaultMemoizeOptions } from 'reselect';
import { Dispatch } from 'redux';
import { Draft } from 'immer';
import { enablePatches } from 'immer';
import { EqualityFn } from 'reselect';
import { freeze } from 'immer';
import { isDraft } from 'immer';
import { isDraftable } from 'immer';
import { Middleware } from 'redux';
import { MiddlewareAPI } from 'redux';
import { original } from 'immer';
import { OutputParametricSelector } from 'reselect';
import { OutputSelector } from 'reselect';
import { ParametricSelector } from 'reselect';
import { Patch } from 'immer';
import { produceWithPatches } from 'immer';
import { Reducer } from 'redux';
import { ReducersMapObject } from 'redux';
import { Selector } from 'reselect';
import { StateFromReducersMapObject } from 'redux';
import { Store } from 'redux';
import { StoreEnhancer } from 'redux';
import { thunk } from 'redux-thunk';
import { ThunkAction } from 'redux-thunk';
import { ThunkDispatch } from 'redux-thunk';
import { ThunkMiddleware } from 'redux-thunk';
import { UnknownAction } from 'redux';
import { weakMapMemoize } from 'reselect';
import { withExtraArgument } from 'redux-thunk';

// @public (undocumented)
export interface ActionCreatorInvariantMiddlewareOptions {
    isActionCreator?: (action: unknown) => action is Function & {
        type?: unknown;
    };
}

// @public
export interface ActionCreatorWithNonInferrablePayload<T extends string = string> extends BaseActionCreator<unknown, T> {
    <PT extends unknown>(payload: PT): PayloadAction<PT, T>;
}

// @public
export interface ActionCreatorWithOptionalPayload<P, T extends string = string> extends BaseActionCreator<P, T> {
    (payload?: P): PayloadAction<P, T>;
}

// @public
export interface ActionCreatorWithoutPayload<T extends string = string> extends BaseActionCreator<undefined, T> {
    (noArgument: void): PayloadAction<undefined, T>;
}

// @public
export interface ActionCreatorWithPayload<P, T extends string = string> extends BaseActionCreator<P, T> {
    (payload: P): PayloadAction<P, T>;
}

// @public
export interface ActionCreatorWithPreparedPayload<Args extends unknown[], P, T extends string = string, E = never, M = never> extends BaseActionCreator<P, T, M, E> {
    (...args: Args): PayloadAction<P, T, M, E>;
}

// @public (undocumented)
export type ActionMatchingAllOf<Matchers extends [...Matcher<any>[]]> = UnionToIntersection<ActionMatchingAnyOf<Matchers>>;

// @public (undocumented)
export type ActionMatchingAnyOf<Matchers extends [...Matcher<any>[]]> = ActionFromMatcher<Matchers[number]>;

// @public
export interface ActionReducerMapBuilder<State> {
    addCase<ActionCreator extends TypedActionCreator<string>>(actionCreator: ActionCreator, reducer: CaseReducer<State, ReturnType<ActionCreator>>): ActionReducerMapBuilder<State>;
    addCase<Type extends string, A extends Action<Type>>(type: Type, reducer: CaseReducer<State, A>): ActionReducerMapBuilder<State>;
    addDefaultCase(reducer: CaseReducer<State, Action>): {};
    addMatcher<A>(matcher: TypeGuard<A> | ((action: any) => boolean), reducer: CaseReducer<State, A extends Action ? A : A & Action>): Omit<ActionReducerMapBuilder<State>, 'addCase'>;
}

// @public @deprecated
export type Actions<T extends keyof any = string> = Record<T, Action>;

// @public (undocumented)
export const addListener: TypedAddListener<unknown, ThunkDispatch<unknown, unknown, UnknownAction>, unknown, ListenerEntry<unknown, ThunkDispatch<unknown, unknown, UnknownAction>>, "listenerMiddleware/add">;

// @internal (undocumented)
export type AnyListenerPredicate<State> = (action: UnknownAction, currentState: State, originalState: State) => boolean;

// @public (undocumented)
export interface AsyncTaskExecutor<T> {
    // (undocumented)
    (forkApi: ForkedTaskAPI): Promise<T>;
}

// @public
export type AsyncThunk<Returned, ThunkArg, ThunkApiConfig extends AsyncThunkConfig> = AsyncThunkActionCreator<Returned, ThunkArg, ThunkApiConfig> & {
    pending: AsyncThunkPendingActionCreator<ThunkArg, ThunkApiConfig>;
    rejected: AsyncThunkRejectedActionCreator<ThunkArg, ThunkApiConfig>;
    fulfilled: AsyncThunkFulfilledActionCreator<Returned, ThunkArg, ThunkApiConfig>;
    typePrefix: string;
};

// @public
export type AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig extends AsyncThunkConfig> = (dispatch: GetDispatch_2<ThunkApiConfig>, getState: () => GetState_2<ThunkApiConfig>, extra: GetExtra<ThunkApiConfig>) => Promise<ReturnType<AsyncThunkFulfilledActionCreator<Returned, ThunkArg>> | ReturnType<AsyncThunkRejectedActionCreator<ThunkArg, ThunkApiConfig>>> & {
    abort: (reason?: string) => void;
    requestId: string;
    arg: ThunkArg;
    unwrap: () => Promise<Returned>;
};

// @public
export type AsyncThunkOptions<ThunkArg = void, ThunkApiConfig extends AsyncThunkConfig = {}> = {
    condition?(arg: ThunkArg, api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>): MaybePromise<boolean | undefined>;
    dispatchConditionRejection?: boolean;
    serializeError?: (x: unknown) => GetSerializedErrorType<ThunkApiConfig>;
    idGenerator?: (arg: ThunkArg) => string;
} & IsUnknown<GetPendingMeta<ThunkApiConfig>, {
    getPendingMeta?(base: {
        arg: ThunkArg;
        requestId: string;
    }, api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>): GetPendingMeta<ThunkApiConfig>;
}, {
    getPendingMeta(base: {
        arg: ThunkArg;
        requestId: string;
    }, api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>): GetPendingMeta<ThunkApiConfig>;
}>;

// @public
export type AsyncThunkPayloadCreator<Returned, ThunkArg = void, ThunkApiConfig extends AsyncThunkConfig = {}> = (arg: ThunkArg, thunkAPI: GetThunkAPI<ThunkApiConfig>) => AsyncThunkPayloadCreatorReturnValue<Returned, ThunkApiConfig>;

// @public
export type AsyncThunkPayloadCreatorReturnValue<Returned, ThunkApiConfig extends AsyncThunkConfig> = MaybePromise<IsUnknown<GetFulfilledMeta<ThunkApiConfig>, Returned, FulfillWithMeta<Returned, GetFulfilledMeta<ThunkApiConfig>>> | RejectWithValue<GetRejectValue<ThunkApiConfig>, GetRejectedMeta<ThunkApiConfig>>>;

// @public
export const autoBatchEnhancer: (options?: AutoBatchOptions) => StoreEnhancer;

// @public (undocumented)
export type AutoBatchOptions = {
    type: 'tick';
} | {
    type: 'timer';
    timeout: number;
} | {
    type: 'raf';
} | {
    type: 'callback';
    queueNotification: (notify: () => void) => void;
};

export { autotrackMemoize }

// @public
export type CaseReducer<S = any, A extends Action = UnknownAction> = (state: Draft<S>, action: A) => NoInfer<S> | void | Draft<NoInfer<S>>;

// @public
export type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>, SliceName extends string> = {
    [Type in keyof CaseReducers]: CaseReducers[Type] extends infer Definition ? Definition extends {
        prepare: any;
    } ? ActionCreatorForCaseReducerWithPrepare<Definition, SliceActionType<SliceName, Type>> : Definition extends AsyncThunkSliceReducerDefinition<any, infer ThunkArg, infer Returned, infer ThunkApiConfig> ? AsyncThunk<Returned, ThunkArg, ThunkApiConfig> : Definition extends {
        reducer: any;
    } ? ActionCreatorForCaseReducer<Definition['reducer'], SliceActionType<SliceName, Type>> : ActionCreatorForCaseReducer<Definition, SliceActionType<SliceName, Type>> : never;
};

// @public @deprecated
export type CaseReducers<S, AS extends Actions> = {
    [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void;
};

// @public
export type CaseReducerWithPrepare<State, Action extends PayloadAction> = {
    reducer: CaseReducer<State, Action>;
    prepare: PrepareAction<Action['payload']>;
};

// @public (undocumented)
export const clearAllListeners: ActionCreatorWithoutPayload<"listenerMiddleware/removeAll">;

// @public (undocumented)
export function combineSlices<Slices extends [
AnySliceLike | ReducerMap,
...Array<AnySliceLike | ReducerMap>
]>(...slices: Slices): CombinedSliceReducer<Id<InitialState<Slices>>>;

// @public (undocumented)
export type Comparer<T> = (a: T, b: T) => number;

// @internal
export function configureStore<S = any, A extends Action = UnknownAction, M extends Tuple<Middlewares<S>> = Tuple<[ThunkMiddlewareFor<S>]>, E extends Tuple<Enhancers> = Tuple<[
StoreEnhancer<{
    dispatch: ExtractDispatchExtensions<M>;
}>,
StoreEnhancer
]>, P = S>(options: ConfigureStoreOptions<S, A, M, E, P>): EnhancedStore<S, A, E>;

// @public
export interface ConfigureStoreOptions<S = any, A extends Action = UnknownAction, M extends Tuple<Middlewares<S>> = Tuple<Middlewares<S>>, E extends Tuple<Enhancers> = Tuple<Enhancers>, P = S> {
    devTools?: boolean | DevToolsEnhancerOptions;
    enhancers?: (getDefaultEnhancers: GetDefaultEnhancers<M>) => E;
    middleware?: ((getDefaultMiddleware: GetDefaultMiddleware<S>) => M) | M;
    preloadedState?: P;
    reducer: Reducer<S, A, P> | ReducersMapObject<S, A, P>;
}

// @public
export function createAction<P = void, T extends string = string>(type: T): PayloadActionCreator<P, T>;

// @public
export function createAction<PA extends PrepareAction<any>, T extends string = string>(type: T, prepareAction: PA): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>;

// @public (undocumented)
export function createActionCreatorInvariantMiddleware(options?: ActionCreatorInvariantMiddlewareOptions): Middleware;

// @public (undocumented)
export const createAsyncThunk: CreateAsyncThunk<AsyncThunkConfig>;

// @public
export const createDraftSafeSelector: CreateSelectorFunction<(...args: unknown[]) => unknown, typeof defaultMemoize, [equalityCheckOrOptions?: EqualityFn | DefaultMemoizeOptions | undefined], {
clearCache: () => void;
}>;

// @public (undocumented)
export const createDraftSafeSelectorCreator: typeof createSelectorCreator;

// @public (undocumented)
export const createDynamicMiddleware: <State = any, Dispatch extends Dispatch<UnknownAction> = Dispatch<UnknownAction>>() => DynamicMiddlewareInstance<State, Dispatch>;

// @public (undocumented)
export function createEntityAdapter<T, Id extends EntityId>(options: {
    selectId: IdSelector<T, Id>;
    sortComparer?: false | Comparer<T>;
}): EntityAdapter<T, Id>;

// @public (undocumented)
export function createEntityAdapter<T extends {
    id: EntityId;
}>(options?: {
    sortComparer?: false | Comparer<T>;
}): EntityAdapter<T, T['id']>;

// @public
export function createImmutableStateInvariantMiddleware(options?: ImmutableStateInvariantMiddlewareOptions): Middleware;

// @public (undocumented)
export function createListenerMiddleware<S = unknown, D extends Dispatch<Action> = ThunkDispatch<S, unknown, UnknownAction>, ExtraArgument = unknown>(middlewareOptions?: CreateListenerMiddlewareOptions<ExtraArgument>): ListenerMiddlewareInstance<S, D, ExtraArgument>;

// @public (undocumented)
export interface CreateListenerMiddlewareOptions<ExtraArgument = unknown> {
    // (undocumented)
    extra?: ExtraArgument;
    onError?: ListenerErrorHandler;
}

export { createNextState }

// @public
export function createReducer<S extends NotFunction<any>>(initialState: S | (() => S), mapOrBuilderCallback: (builder: ActionReducerMapBuilder<S>) => void): ReducerWithInitialState<S>;

export { createSelector }

export { createSelectorCreator }

export { CreateSelectorFunction }

// @public
export function createSerializableStateInvariantMiddleware(options?: SerializableStateInvariantMiddlewareOptions): Middleware;

// @public
export function createSlice<State, CaseReducers extends SliceCaseReducers<State>, Name extends string, Selectors extends SliceSelectors<State>, ReducerPath extends string = Name>(options: CreateSliceOptions<State, CaseReducers, Name, ReducerPath, Selectors>): Slice<State, CaseReducers, Name, ReducerPath, Selectors>;

// @public
export interface CreateSliceOptions<State = any, CR extends SliceCaseReducers<State> = SliceCaseReducers<State>, Name extends string = string, ReducerPath extends string = Name, Selectors extends SliceSelectors<State> = SliceSelectors<State>> {
    extraReducers?: (builder: ActionReducerMapBuilder<State>) => void;
    initialState: State | (() => State);
    name: Name;
    reducerPath?: ReducerPath;
    reducers: ValidateSliceCaseReducers<State, CR> | ((creators: ReducerCreators<State>) => CR);
    selectors?: Selectors;
}

export { current }

export { defaultMemoize }

// @public (undocumented)
export interface DevToolsEnhancerOptions {
    actionCreators?: ActionCreator<any>[] | {
        [key: string]: ActionCreator<any>;
    };
    actionsAllowlist?: string | string[];
    actionSanitizer?: <A extends Action>(action: A, id: number) => A;
    actionsDenylist?: string | string[];
    autoPause?: boolean;
    features?: {
        pause?: boolean;
        lock?: boolean;
        persist?: boolean;
        export?: boolean | 'custom';
        import?: boolean | 'custom';
        jump?: boolean;
        skip?: boolean;
        reorder?: boolean;
        dispatch?: boolean;
        test?: boolean;
    };
    latency?: number;
    maxAge?: number;
    name?: string;
    pauseActionType?: string;
    predicate?: <S, A extends Action>(state: S, action: A) => boolean;
    serialize?: boolean | {
        options?: undefined | boolean | {
            date?: true;
            regex?: true;
            undefined?: true;
            error?: true;
            symbol?: true;
            map?: true;
            set?: true;
            function?: true | ((fn: (...args: any[]) => any) => string);
        };
        replacer?: (key: string, value: unknown) => any;
        reviver?: (key: string, value: unknown) => any;
        immutable?: any;
        refs?: any;
    };
    shouldCatchErrors?: boolean;
    shouldHotReload?: boolean;
    shouldRecordChanges?: boolean;
    shouldStartLocked?: boolean;
    stateSanitizer?: <S>(state: S, index: number) => S;
    trace?: boolean | (<A extends Action>(action: A) => string);
    traceLimit?: number;
}

export { Draft }

// @public (undocumented)
export type DynamicMiddlewareInstance<State = unknown, Dispatch extends Dispatch<UnknownAction> = Dispatch<UnknownAction>> = {
    middleware: DynamicMiddleware<State, Dispatch>;
    addMiddleware: AddMiddleware<State, Dispatch>;
    withMiddleware: WithMiddleware<State, Dispatch>;
};

export { enablePatches }

// @public
export type EnhancedStore<S = any, A extends Action = UnknownAction, E extends Enhancers = Enhancers> = ExtractStoreExtensions<E> & Store<S & ExtractStateExtensions<E>, A>;

// @public (undocumented)
export interface EntityAdapter<T, Id extends EntityId> extends EntityStateAdapter<T, Id> {
    // (undocumented)
    getInitialState(): EntityState<T, Id>;
    // (undocumented)
    getInitialState<S extends object>(state: S): EntityState<T, Id> & S;
    // (undocumented)
    getSelectors(selectState?: undefined, options?: GetSelectorsOptions): EntitySelectors<T, EntityState<T, Id>, Id>;
    // (undocumented)
    getSelectors<V>(selectState: (state: V) => EntityState<T, Id>, options?: GetSelectorsOptions): EntitySelectors<T, V, Id>;
    // (undocumented)
    selectId: IdSelector<T, Id>;
    // (undocumented)
    sortComparer: false | Comparer<T>;
}

// @public (undocumented)
export type EntityId = number | string;

// @public (undocumented)
export interface EntitySelectors<T, V, Id extends EntityId> {
    // (undocumented)
    selectAll: (state: V) => T[];
    // (undocumented)
    selectById: (state: V, id: Id) => Id<UncheckedIndexedAccess<T>>;
    // (undocumented)
    selectEntities: (state: V) => Record<Id, T>;
    // (undocumented)
    selectIds: (state: V) => Id[];
    // (undocumented)
    selectTotal: (state: V) => number;
}

// @public (undocumented)
export interface EntityState<T, Id extends EntityId> {
    // (undocumented)
    entities: Record<Id, T>;
    // (undocumented)
    ids: Id[];
}

// @public (undocumented)
export interface EntityStateAdapter<T, Id extends EntityId> {
    // (undocumented)
    addMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entities: readonly T[] | Record<Id, T>): S;
    // (undocumented)
    addMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entities: PayloadAction<readonly T[] | Record<Id, T>>): S;
    // (undocumented)
    addOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entity: T): S;
    // (undocumented)
    addOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, action: PayloadAction<T>): S;
    // (undocumented)
    removeAll<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>): S;
    // (undocumented)
    removeMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, keys: readonly Id[]): S;
    // (undocumented)
    removeMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, keys: PayloadAction<readonly Id[]>): S;
    // (undocumented)
    removeOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, key: Id): S;
    // (undocumented)
    removeOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, key: PayloadAction<Id>): S;
    // (undocumented)
    setAll<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entities: readonly T[] | Record<Id, T>): S;
    // (undocumented)
    setAll<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entities: PayloadAction<readonly T[] | Record<Id, T>>): S;
    // (undocumented)
    setMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entities: readonly T[] | Record<Id, T>): S;
    // (undocumented)
    setMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entities: PayloadAction<readonly T[] | Record<Id, T>>): S;
    // (undocumented)
    setOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entity: T): S;
    // (undocumented)
    setOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, action: PayloadAction<T>): S;
    // (undocumented)
    updateMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, updates: ReadonlyArray<Update<T, Id>>): S;
    // (undocumented)
    updateMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, updates: PayloadAction<ReadonlyArray<Update<T, Id>>>): S;
    // (undocumented)
    updateOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, update: Update<T, Id>): S;
    // (undocumented)
    updateOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, update: PayloadAction<Update<T, Id>>): S;
    // (undocumented)
    upsertMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entities: readonly T[] | Record<Id, T>): S;
    // (undocumented)
    upsertMany<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entities: PayloadAction<readonly T[] | Record<Id, T>>): S;
    // (undocumented)
    upsertOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entity: T): S;
    // (undocumented)
    upsertOne<S extends EntityState<T, Id>>(state: PreventAny<S, T, Id>, entity: PayloadAction<T>): S;
}

// @public (undocumented)
export function findNonSerializableValue(value: unknown, path?: string, isSerializable?: (value: unknown) => boolean, getEntries?: (value: unknown) => [string, any][], ignoredPaths?: IgnorePaths_2, cache?: WeakSet<object>): NonSerializableValue | false;

// @public (undocumented)
export interface ForkedTask<T> {
    cancel(): void;
    result: Promise<TaskResult<T>>;
}

// @public (undocumented)
export interface ForkedTaskAPI {
    delay(timeoutMs: number): Promise<void>;
    pause<W>(waitFor: Promise<W>): Promise<W>;
    signal: AbortSignal;
}

// @public (undocumented)
export type ForkedTaskExecutor<T> = AsyncTaskExecutor<T> | SyncTaskExecutor<T>;

export { freeze }

// @public (undocumented)
export type GetDispatch<MiddlewareApiConfig> = MiddlewareApiConfig extends {
    dispatch: infer Dispatch;
} ? FallbackIfUnknown<Dispatch, Dispatch> : Dispatch;

// @public (undocumented)
export type GetState<MiddlewareApiConfig> = MiddlewareApiConfig extends {
    state: infer State;
} ? State : unknown;

// @public (undocumented)
export type IdSelector<T, Id extends EntityId> = (model: T) => Id;

// @public
export interface ImmutableStateInvariantMiddlewareOptions {
    ignoredPaths?: IgnorePaths;
    isImmutable?: IsImmutableFunc;
    warnAfter?: number;
}

// @public
export function isAction(action: unknown): action is Action<string>;

// @public
export function isActionCreator(action: unknown): action is BaseActionCreator<unknown, string> & Function;

// @public
export function isAllOf<Matchers extends [...Matcher<any>[]]>(...matchers: Matchers): (action: any) => action is UnionToIntersection<ActionFromMatcher<Matchers[number]>>;

// @public
export function isAnyOf<Matchers extends [...Matcher<any>[]]>(...matchers: Matchers): (action: any) => action is ActionFromMatcher<Matchers[number]>;

// @public
export function isAsyncThunkAction(): (action: any) => action is UnknownAsyncThunkAction;

// @public
export function isAsyncThunkAction<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is ActionsFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isAsyncThunkAction(action: any): action is UnknownAsyncThunkAction;

export { isDraft }

export { isDraftable }

// @public
export function isFluxStandardAction(action: unknown): action is {
    type: string;
    payload?: unknown;
    error?: unknown;
    meta?: unknown;
};

// @public
export function isFulfilled(): (action: any) => action is UnknownAsyncThunkFulfilledAction;

// @public
export function isFulfilled<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is FulfilledActionFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isFulfilled(action: any): action is UnknownAsyncThunkFulfilledAction;

// @public
export function isImmutableDefault(value: unknown): boolean;

// @public
export function isPending(): (action: any) => action is UnknownAsyncThunkPendingAction;

// @public
export function isPending<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is PendingActionFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isPending(action: any): action is UnknownAsyncThunkPendingAction;

// @public
export function isPlain(val: any): boolean;

// @public
export function isPlainObject(value: unknown): value is object;

// @public
export function isRejected(): (action: any) => action is UnknownAsyncThunkRejectedAction;

// @public
export function isRejected<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is RejectedActionFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isRejected(action: any): action is UnknownAsyncThunkRejectedAction;

// @public
export function isRejectedWithValue(): (action: any) => action is UnknownAsyncThunkRejectedAction;

// @public
export function isRejectedWithValue<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is RejectedWithValueActionFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isRejectedWithValue(action: any): action is UnknownAsyncThunkRejectedAction;

// @public (undocumented)
export type ListenerEffect<Action extends Action, State, Dispatch extends Dispatch, ExtraArgument = unknown> = (action: Action, api: ListenerEffectAPI<State, Dispatch, ExtraArgument>) => void | Promise<void>;

// @public (undocumented)
export interface ListenerEffectAPI<State, Dispatch extends Dispatch, ExtraArgument = unknown> extends MiddlewareAPI<Dispatch, State> {
    cancelActiveListeners: () => void;
    condition: ConditionFunction<State>;
    delay(timeoutMs: number): Promise<void>;
    // (undocumented)
    extra: ExtraArgument;
    fork<T>(executor: ForkedTaskExecutor<T>, options?: ForkOptions): ForkedTask<T>;
    getOriginalState: () => State;
    pause<M>(promise: Promise<M>): Promise<M>;
    signal: AbortSignal;
    subscribe(): void;
    take: TakePattern<State>;
    unsubscribe(): void;
}

// @public
export interface ListenerErrorHandler {
    // (undocumented)
    (error: unknown, errorInfo: ListenerErrorInfo): void;
}

// @public (undocumented)
export type ListenerMiddleware<State = unknown, Dispatch extends ThunkDispatch<State, unknown, Action> = ThunkDispatch<State, unknown, UnknownAction>, ExtraArgument = unknown> = Middleware<{
    (action: Action<'listenerMiddleware/add'>): UnsubscribeListener;
}, State, Dispatch>;

// @public (undocumented)
export interface ListenerMiddlewareInstance<State = unknown, Dispatch extends ThunkDispatch<State, unknown, Action> = ThunkDispatch<State, unknown, UnknownAction>, ExtraArgument = unknown> {
    clearListeners: () => void;
    // (undocumented)
    middleware: ListenerMiddleware<State, Dispatch, ExtraArgument>;
    // (undocumented)
    startListening: AddListenerOverloads<UnsubscribeListener, State, Dispatch, ExtraArgument>;
    // (undocumented)
    stopListening: RemoveListenerOverloads<State, Dispatch>;
}

// @public (undocumented)
export type MiddlewareApiConfig = {
    state?: unknown;
    dispatch?: Dispatch;
};

// @public
export const miniSerializeError: (value: any) => SerializedError;

// @public (undocumented)
export let nanoid: (size?: number) => string;

export { original }

export { OutputParametricSelector }

export { OutputSelector }

export { ParametricSelector }

export { Patch }

// @public
export type PayloadAction<P = void, T extends string = string, M = never, E = never> = {
    payload: P;
    type: T;
} & ([M] extends [never] ? {} : {
    meta: M;
}) & ([E] extends [never] ? {} : {
    error: E;
});

// @public
export type PayloadActionCreator<P = void, T extends string = string, PA extends PrepareAction<P> | void = void> = IfPrepareActionMethodProvided<PA, _ActionCreatorWithPreparedPayload<PA, T>, IsAny<P, ActionCreatorWithPayload<any, T>, IsUnknownOrNonInferrable<P, ActionCreatorWithNonInferrablePayload<T>, IfVoid<P, ActionCreatorWithoutPayload<T>, IfMaybeUndefined<P, ActionCreatorWithOptionalPayload<P, T>, ActionCreatorWithPayload<P, T>>>>>>;

// @public
export type PrepareAction<P> = ((...args: any[]) => {
    payload: P;
}) | ((...args: any[]) => {
    payload: P;
    meta: any;
}) | ((...args: any[]) => {
    payload: P;
    error: any;
}) | ((...args: any[]) => {
    payload: P;
    meta: any;
    error: any;
});

// @public (undocumented)
export const prepareAutoBatched: <T>() => (payload: T) => {
    payload: T;
    meta: unknown;
};

export { produceWithPatches }

// @public (undocumented)
export interface ReducerCreators<State> {
    // (undocumented)
    asyncThunk: AsyncThunkCreator<State>;
    // (undocumented)
    preparedReducer<Prepare extends PrepareAction<any>>(prepare: Prepare, reducer: CaseReducer<State, ReturnType<_ActionCreatorWithPreparedPayload<Prepare>>>): {
        _reducerDefinitionType: ReducerType.reducerWithPrepare;
        prepare: Prepare;
        reducer: CaseReducer<State, ReturnType<_ActionCreatorWithPreparedPayload<Prepare>>>;
    };
    // (undocumented)
    reducer(caseReducer: CaseReducer<State, PayloadAction>): CaseReducerDefinition<State, PayloadAction>;
    // (undocumented)
    reducer<Payload>(caseReducer: CaseReducer<State, PayloadAction<Payload>>): CaseReducerDefinition<State, PayloadAction<Payload>>;
}

// @public (undocumented)
export enum ReducerType {
    // (undocumented)
    asyncThunk = "asyncThunk",
    // (undocumented)
    reducer = "reducer",
    // (undocumented)
    reducerWithPrepare = "reducerWithPrepare"
}

// @public (undocumented)
export const removeListener: TypedRemoveListener<unknown, ThunkDispatch<unknown, unknown, UnknownAction>, ListenerEntry<unknown, ThunkDispatch<unknown, unknown, UnknownAction>>, "listenerMiddleware/remove">;

export { Selector }

// @public
export interface SerializableStateInvariantMiddlewareOptions {
    disableCache?: boolean;
    getEntries?: (value: any) => [string, any][];
    ignoreActions?: boolean;
    ignoredActionPaths?: (string | RegExp)[];
    ignoredActions?: string[];
    ignoredPaths?: (string | RegExp)[];
    ignoreState?: boolean;
    isSerializable?: (value: any) => boolean;
    warnAfter?: number;
}

// @public (undocumented)
export interface SerializedError {
    // (undocumented)
    code?: string;
    // (undocumented)
    message?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    stack?: string;
}

// @public (undocumented)
export const SHOULD_AUTOBATCH = "RTK_autoBatch";

// @public
export interface Slice<State = any, CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>, Name extends string = string, ReducerPath extends string = Name, Selectors extends SliceSelectors<State> = SliceSelectors<State>> {
    actions: CaseReducerActions<CaseReducers, Name>;
    caseReducers: SliceDefinedCaseReducers<CaseReducers>;
    getInitialState: () => State;
    getSelectors(): Id<SliceDefinedSelectors<State, Selectors, State>>;
    getSelectors<RootState>(selectState: (rootState: RootState) => State): Id<SliceDefinedSelectors<State, Selectors, RootState>>;
    injectInto<NewReducerPath extends string = ReducerPath>(injectable: {
        inject: (slice: {
            reducerPath: string;
            reducer: Reducer;
        }, config?: InjectConfig) => void;
    }, config?: InjectIntoConfig<NewReducerPath>): InjectedSlice<State, CaseReducers, Name, NewReducerPath, Selectors>;
    name: Name;
    reducer: Reducer<State>;
    reducerPath: ReducerPath;
    selectors: Id<SliceDefinedSelectors<State, Selectors, {
        [K in ReducerPath]: State;
    }>>;
}

// @public
export type SliceCaseReducers<State> = Record<string, CaseReducerDefinition<State, PayloadAction<any>> | CaseReducerWithPrepareDefinition<State, PayloadAction<any, string, any, any>> | AsyncThunkSliceReducerDefinition<State, any, any, any>> | Record<string, CaseReducer<State, PayloadAction<any>> | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>>;

// @public
export type SliceSelectors<State> = {
    [K: string]: (sliceState: State, ...args: any[]) => any;
};

// @public (undocumented)
export interface SyncTaskExecutor<T> {
    // (undocumented)
    (forkApi: ForkedTaskAPI): T;
}

// @public (undocumented)
export class TaskAbortError implements SerializedError {
    constructor(code: string | undefined);
    // (undocumented)
    code: string | undefined;
    // (undocumented)
    message: string;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export type TaskCancelled = {
    readonly status: 'cancelled';
    readonly error: TaskAbortError;
};

// @public (undocumented)
export type TaskRejected = {
    readonly status: 'rejected';
    readonly error: unknown;
};

// @public (undocumented)
export type TaskResolved<T> = {
    readonly status: 'ok';
    readonly value: T;
};

// @public (undocumented)
export type TaskResult<Value> = TaskResolved<Value> | TaskRejected | TaskCancelled;

export { thunk }

export { ThunkAction }

export { ThunkDispatch }

export { ThunkMiddleware }

// @public
export type TypedAddListener<State, Dispatch extends Dispatch = ThunkDispatch<State, unknown, UnknownAction>, ExtraArgument = unknown, Payload = ListenerEntry<State, Dispatch>, T extends string = 'listenerMiddleware/add'> = BaseActionCreator<Payload, T> & AddListenerOverloads<PayloadAction<Payload, T>, State, Dispatch, ExtraArgument>;

// @public
export type TypedRemoveListener<State, Dispatch extends Dispatch = ThunkDispatch<State, unknown, UnknownAction>, Payload = ListenerEntry<State, Dispatch>, T extends string = 'listenerMiddleware/remove'> = BaseActionCreator<Payload, T> & AddListenerOverloads<PayloadAction<Payload, T>, State, Dispatch, any, UnsubscribeListenerOptions>;

// @public
export type TypedStartListening<State, Dispatch extends Dispatch = ThunkDispatch<State, unknown, UnknownAction>, ExtraArgument = unknown> = AddListenerOverloads<UnsubscribeListener, State, Dispatch, ExtraArgument>;

// @public
export type TypedStopListening<State, Dispatch extends Dispatch = ThunkDispatch<State, unknown, UnknownAction>> = RemoveListenerOverloads<State, Dispatch>;

// @public (undocumented)
export type UnsubscribeListener = (unsubscribeOptions?: UnsubscribeListenerOptions) => void;

// @public (undocumented)
export interface UnsubscribeListenerOptions {
    // (undocumented)
    cancelActive?: true;
}

// @public (undocumented)
export function unwrapResult<R extends UnwrappableAction>(action: R): UnwrappedActionPayload<R>;

// @public (undocumented)
export type Update<T, Id extends EntityId> = {
    id: Id;
    changes: Partial<T>;
};

// @public
export type ValidateSliceCaseReducers<S, ACR extends SliceCaseReducers<S>> = ACR & {
    [T in keyof ACR]: ACR[T] extends {
        reducer(s: S, action?: infer A): any;
    } ? {
        prepare(...a: never[]): Omit<A, 'type'>;
    } : {};
};

export { weakMapMemoize }

export { withExtraArgument }

// @public (undocumented)
export type WithSlice<A extends AnySliceLike> = {
    [Path in SliceLikeReducerPath<A>]: SliceLikeState<A>;
};


export * from "redux";

// (No @packageDocumentation comment for this package)

```
